<!DOCTYPE html>
<html>
  <head>
    <title>Testing av JavaScript</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.5.min.js" type="text/javascript"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.js" type="text/javascript"></script>
    <link href="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.css" type="text/css" rel="stylesheet">
    <style type="text/css" media="screen">
      #slideshow .slide .content.front-page h1 { width: 100%; }
      .slide p { padding: 0; margin: 1.1em 0; }
      .slide ul { padding: 0; margin: 1.1em 0; }
      .slide img { max-width: 100%; max-height: 600px; }
      #slideshow .slide .content ul li { padding-left: 1.3em; }
    </style>
  </head>
  <body>
    <textarea id="source">

.front-page

# Bygg en testbar Javascript-applikasjon

## Workshop 19/06/2012

Kim Joar Bekkelund

og

Tine Kleivane

---

# Utbytte

Se reelle eksempler på testing av JavaScript

* Både gode og dårlige måter
* Diskutere virkningene av denne typen testing

Et forslag til abstraksjoner og en JavaScript-arkitektur

* Struktur å måle både andre rammeverk og egne applikasjoner mot

---

# Utbytte

Vi skal lære å *ikke* skrive kode som dette:

    .javascript
    // page event
    jQuery(function() {
      //                 user event
      $("#profile form").submit(function(event) {
        event.preventDefault();
        // network IO
        $.ajax({
          // ...

          // network event
          success: function(data) {
            // parsing respons
            var name = data.name ? data.name : "Unknown";
            // template
            var html = "<h1>" + name + "</h1>";
            // oppdatering av DOM-en
            $("#profile .info").append(html);
          }
        });
      });
    }

Dette er komplekst og veldig vanskelig å teste!

---

.middle.center

Men først …

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){
















    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){










      // Selve testen
      it("says hello", function(){



      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){










      // Selve testen
      it("says hello", function(){
        expect(BEKK.helloWorld()).toEqual("hello world");


      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){










      // Selve testen
      it("says hello", function(){
        expect(BEKK.helloWorld()).toEqual("hello world");
        // Finnes mange matchere, blant annet:
        // `toBe`, `toMatch`, `toBeDefined`, `toBeTruthy`, `toContain`, osv
      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){
      beforeEach(function(){
        // Kjører før hver test


      });

      afterEach(function(){
        // Kjører etter hver test
      });

      // Selve testen
      it("says hello", function(){
        expect(BEKK.helloWorld()).toEqual("hello world");
        // Finnes mange matchere, blant annet:
        // `toBe`, `toMatch`, `toBeDefined`, `toBeTruthy`, `toContain`, osv
      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter

---

# Intro til Jasmine

    .javascript
    // Gruppering av tester
    describe("My tests", function(){
      beforeEach(function(){
        // Kjører før hver test

        this.hello = BEKK.helloWorld();
      });

      afterEach(function(){
        // Kjører etter hver test
      });

      // Selve testen
      it("says hello", function(){
        expect(this.hello).toEqual("hello world");
        // Finnes mange matchere, blant annet:
        // `toBe`, `toMatch`, `toBeDefined`, `toBeTruthy`, `toContain`, osv
      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Brukes på flere BEKK-prosjekter


---

# Intro til Jasmine

Kan kjøres i nettleseren eller med Maven

Kan kjøre asynkrone kall med `runs` og `waits`

For å ikke kjøre spesifikke tester: `xdescribe` og `xit`

Noen rariteter:

* dersom man ikke har en `expect` kjører fortsatt testen grønt …
* dersom en testfil har en syntaksfeil sier ikke Jasmine fra (den bare skipper filen). Følg med i konsollen!

---

.pushed

![](images/monolog_cropped.png)

# Målet

Lage en superenkel Twitter-lignende applikasjon: *Monolog*

---

.middle.center

Views

---

.middle.center

Hva er et view?

---

#Views

![](images/monolog_views.png)

---

# Views

Et view eier et DOM-element, som vi vil kalle `el`.

Vi sender alltid med DOM-elementet når vi lager et view

Det er kun views som har lov til å røre DOM-en!

---

# Views

Vi skal benytte et lite bibliotek: Simple.js

Det er egentlig bare noen små abstraksjoner og ca 100 linjer totalt.

God dokumentasjon på
[http://simplejs.org](http://simplejs.org)

---

# Views

Hvordan lage et nytt view:

    .javascript
    // Vi kan lage views ved å bruke `extend`
    var UserView = Simple.View.extend({












    });



    &nbsp;

---

# Views

Hvordan lage et nytt view:

    .javascript
    // Vi kan lage views ved å bruke `extend`
    var UserView = Simple.View.extend({












    });

    // Lager en instans (og sender med `el`)
    var view = new UserView({ el: $("#profile") });
    &nbsp;

---

# Views

Hvordan lage et nytt view:

    .javascript
    // Vi kan lage views ved å bruke `extend`
    var UserView = Simple.View.extend({

      // Vi kan legge til instansmetoder.
      // I disse metodene har vi `this` tilgjengelig.

      initialize: function(options) {
        // Kjøres automatisk når et view initialiseres
        // Tar imot et argument, en options-hash
      },




    });

    // Lager en instans (og sender med `el`)
    var view = new UserView({ el: $("#profile") });
    &nbsp;

---

# Views

Hvordan lage et nytt view:

    .javascript
    // Vi kan lage views ved å bruke `extend`
    var UserView = Simple.View.extend({

      // Vi kan legge til instansmetoder.
      // I disse metodene har vi `this` tilgjengelig.

      initialize: function(options) {
        // Kjøres automatisk når et view initialiseres
        // Tar imot et argument, en options-hash
      },

      showUserInfo: function(){
        // View-logikk og rendering
      };
    });

    // Lager en instans (og sender med `el`)
    var view = new UserView({ el: $("#profile") });
    view.showUserInfo();

---

.middle.center

# Setup

All kode ligger på [http://goo.gl/V8RDz](http://goo.gl/V8RDz)

Åpne `test/SpecRunner.html` for å kjøre testene.

---

# Oppgave

Vi skal starte med å se på profilseksjonen.

To aktuelle filer:

* `app.js`
* `test/spec/userViewSpec.js`

For å kjøre testene, åpne `test/SpecRunner.html`

Oppgaven:

    .javascript
    describe("The user view", function() {
      it("should have a user when initialized", function() {
        var user = {};

        // Initialiser et nytt view
        // (trenger ikke sende med `el` enda)

        expect(view.user).toBeDefined();
      });
    });

---

.middle.center

Gjennomgang oppgave

---

# View-rendring

Et view eier et element, `el`.

`template` inneholder ren HTML som skal inn i viewet. Vi har laget alle
templates som trengs på forhånd.

Det er metoden `render` sitt ansvar er å interpolere data i template og
plassere dette i `el`.

    .javascript
    var UserView = Simple.View.extend({
      template: '<h2>{{name}}</h2>',

      initialize: function(options) {
        this.user = options.user;
      },

      render: function(){
        var html = Mustache.to_html(this.template, this.user);
        this.el.html(html);
      }
    });

---

# Lagarkitektur

Veldig enkelt å lage en lagarkitektur:

    .javascript
    BEKK.View = Simple.View.extend({
      renderTemplate: function(data) {
        var html = Mustache.to_html(this.template, data);
        this.el.html(html);
      }
    });

Lag nye views basert med `BEKK.View.extend`:

    .javascript
    BEKK.UserView = BEKK.View.extend({
      // template, initialize, osv...

      render: function() {
        // delt funksjonalitet er bra!
        this.renderTemplate(this.user);
      }
    });

---

# Hvordan teste view-rendering?

    .javascript
    var userView = new BEKK.UserView({ el: $("#profile") });

Hva er problemet?

For å teste viewet trenger vi tilgang til `.javascript $("#profile")`

Mulig løsning:

* Sette alt opp i DOM-en, for eksempel legg relevant HTML i `test/SpecRunner.html`

Mye oppsett, mye kopiering, og generelt sett ganske kjipt.

---

# Bedre løsning

Vi lager et dummy-objekt som bare finnes i minne, som for eksempel
`.javascript $("<div></div>")`. Send inn de elementene viewet forventer å få
som input.

Eksempel:

    .javascript
    var view = new BEKK.UserView({ el: $("<div></div>" ) })

Vi har lagt til en hjelpemetode for å sjekke innholdet i HTML-en til et view:

    .javascript
    expect(view).toContainInEl("En string");

---

# Oppgave

    .javascript
    it("should show user info when rendered", function(){
        var user = {
            name: "Test Testesen"
        };

        // Sjekk at navnet finnes i `el`
    });

Hint:

* `BEKK.View` — Må kommenteres inn i `app.js`
* `render`
* `expect(...).toContainInEl()`

---

# Gjennomgang oppgave

Test:

    .javascript
    it("should show user info when rendered", function(){
        var user = {
            name: "Test Testesen"
        };

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" ) });
        view.render();

        expect(view).toContainInEl("Test Testesen");
    });

Kode:

    .javascript
    BEKK.UserView = BEKK.View.extend({

      //...

      render: function() {
        var data = this.user;
        this.renderTemplate(data);
      }
    });

Vi extend-er fra `BEKK.View` for å samle felles view-logikk.

---

# Oppslag i DOM-en

Vi bruker `$(selector)` for ofte, og det gjør oss koblet til DOM-en.

Men nå sender vi med `el` til alle views og kan dermed slå opp lokalt i
viewets DOM med `view.DOM`-funksjonen.

    .javascript
    // går fra
    $("#profile form")

    // til
    userView.DOM("form")

    // disse er ekvivalente om `#profile` er `el`-en til `userView`

Løsningen med bruk av `toContainInEl` blir for enkel siden den søker etter en
string i hele HTML-en.

---

# Oppgave

Så la oss bruke `DOM`-funksjonen istedenfor `toContainInEl`:

    .javascript
    it("should show user info when rendered", function(){
        // sjekk at `h2` inneholder korrekt navn
    });

(Målet i denne oppgaven er å refaktorere den forrige testen, ikke skrive ny
funksjonalitet.)

---

# Gjennomgang

Test:

    .javascript
    it("should show user info when rendered", function(){
        var user = {
            name: "Test Testesen"
        };

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" ) });
        view.render();

        expect(view.DOM("h2")).toHaveText("Test Testesen");
    });

Ingen implementasjon, følger med Simple.js

---

# Model

Har ansvar for data og opphenting av denne

---

# Model

Har ansvar for data og opphenting av denne

* Kun modeller som har lov til å kommunisere med serveren

---

# Model

Har ansvar for data og opphenting av denne

* Kun modeller som har lov til å kommunisere med serveren

Det er fire sentrale properties:

* `initialize` — metode som kalles ved initialisering
* `url` — variabel som brukes i AJAX-kall
* `attrs` — metode for å hent ut alle attributtene til en modell
* `attr("key")` og `attr("key", newValue)`

---

# Model

Har ansvar for data og opphenting av denne

* Kun modeller som har lov til å kommunisere med serveren

Det er fire sentrale properties:

* `initialize` — metode som kalles ved initialisering
* `url` — variabel som brukes i AJAX-kall
* `attrs` — metode for å hent ut alle attributtene til en modell
* `attr("key")` og `attr("key", newValue)`


    .javascript
    var model = new Simple.Model();

    model.attr("name", "Tine!");
    model.attr("seniority", "Konsulent");

    model.attr("name"); // Tine!

    model.attrs(); // { name: "Tine!", seniority: "Konsulent" }

    new Simple.Model({ name: "Tine" }); // kan sette attributter ved initialisering

---

.center

![](images/mvt_3.png)

---

# Oppgave

    .javascript
    it("should show user info when rendered", function(){
      // Ny refaktorering:
      // Input til viewet skal være en modell der navn er satt.
    });

---

# Gjennomgang oppgave

Test:

    .javascript
    it("should show user info when rendered", function(){
        var user = new BEKK.User();
        user.attr("name", "Kim Joar Bekkelund");

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" )});
        view.render();

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
    });

Kode:

    .javascript
      BEKK.UserView = BEKK.View.extend({

        //...

        render: function() {
          var data = this.user.attrs();
          this.renderTemplate(data);
        }
      });

---

# Oppgave

Få opp en visning av profilen

    .javascript
    BEKK.start = function() {
      // initialiser modell
      // initialiser view
      // render view
    };

Her trenger dere ikke skrive en test!

Filer:

* `index.html`
* `app.js`

---

# Model

Simple.js inneholder en `fetch`-metode som tar imot et success-callback:

    .javascript
    user.fetch({
      success: function() {
        // håndter suksess
        // nå er alle mottatte verdier satt på `user`
        // hent verdi ved å bruke `attr` eller `attrs`
      }
    });

Bruker `model.url` (og evt `model.dataType`) i AJAX-kall:

    .javascript
    var User = Simple.Model.extend({
      url: "/user",

      dataType: "jsonp" // dersom man trenger å endre bort fra JSON
    });

    var user = new User();
    user.fetch(...)

---

.center

![](images/model_fetch.png)


---

# Oppgave

    .javascript
    it("should show user info when rendered", function() {
        var view;

        // sett opp modell og view, og start henting av data
        // runs(function(){
        // });

        // vi venter på å motta svar fra Twitter
        // waits(1000);

        // sjekk at `el` har rett innhold
        // runs(function(){
        // });
    });

Hint:

* Sett Twitter-brukernavnet på modellen (ved initialisering)

---

# Gjennomgang oppgave

    .javascript
    it("should show user info when rendered", function() {
        var view;
        runs(function(){
            var user = new BEKK.User({ screen_name: "kimjoar" });
            view = new BEKK.UserView({ user: user, el: $('<div></div>') });

            user.fetch({
              success: function() {
                view.render();
              }
            });
        });
        waits(1000);
        runs(function(){
            expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        });
    });

Kode:

    .javascript
    BEKK.User = Simple.Model.extend({
      // ...
      initialize: function() {
          this.url = "https://api.twitter.com/1/users/show.json?screen_name=" +
              this.attr("screen_name");
      }
    });

---

# Hva lærte vi av forrige test?

Dette går treeegt!

Og det er vanskelig å vite hvor tregt. Når vi testet feilet det 1 av 3 ganger på 500ms.

Vanskelig i store prosjekter siden vi må ha en kjørende app i byggeprosessen.

… det må finnes bedre måter å gjøre dette på!

---

# sinon.js

[http://sinonjs.org](http://sinonjs.org)

"Standalone test spies, stubs and mocks for JavaScript. No dependencies, works
with any unit testing framework."

Inneholder også:

* Fake timers for `setTimeout()`
* Fake server &amp; XHR for mocking av AJAX-kall

Det finnes ekstra matchers for Jasmine, se
[https://github.com/froots/jasmine-sinon](https://github.com/froots/jasmine-sinon).

---

# Mocking av AJAX-kall

Vi benytter `sinon.fakeServer`:

    .javascript
    // Setup
    this.server = sinon.fakeServer.create();

    // Setup av en response
    var statusCode = 200;
    var headers = { "Content-Type": "application/json" };
    var data = '[{ "id": 1, "name": "Kim Joar" }]'
    this.server.respondWith([statusCode, headers, data]);

    // Svar på AJAX-kallet
    // (tilstanden mellom AJAX-kallet og respond kan være verdifull)
    this.server.respond()

    // Teardown
    this.server.restore();

* Mye, mye raskere tester
* Responsen kan enkelt tilpasses det vi ønsker å teste
* ... men: Registerer ikke endringer i API-et

---

# Oppgave

    .javascript
    it("should show user info when rendered", function() {
        var response = '{"name": "Kim","followers_count": "2","friends_count": "1"}';
        var options = {};
        var user = new BEKK.User({screen_name: "kimjoar"});

        // sinon.js støtter ikke JSONP
        user.dataType = "json";

        // Sett opp en fakeServer

        // Sjekk for korrekt data i viewet

        // Bryt ned fakeServer
    });

Hint:

* Åpne Twitter-URLen som ligger i modellen, kopier responsen

---

# Gjennomgang oppgave

    .javascript
    it("should show user info when rendered", function() {
        var response = '{"name": "Kim","followers_count": "2","friends_count": "1"}';
        var options = {};
        var server = sinon.fakeServer.create();
        server.respondWith([200, options , response]);

        var user = new BEKK.User({screen_name: "kimjoar"});

        // sinon.js støtter ikke JSONP
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        user.fetch({
          success: function(){
            view.render();
          }
        });

        server.respond();
        server.restore();

        expect(view.DOM("h2")).toHaveText("Kim");
        expect(view.DOM(".followers")).toHaveText("2");
        expect(view.DOM(".following")).toHaveText("1");
    });

---

# Callback

Hvorfor skal koden utenfra vite noe om hvordan viewet skal håndtere respons?

    .javascript
    user.fetch({
      success: function(){
        view.render();
      }
    });

Eller, dersom vi flytter hentingen inn: hvorfor skal viewet være ansvarlig for
å hente sin dataen?

Dette burde være:

    .javascript
    user.fetch();

Og så kan viewet få beskjed ved suksess.

---

# Events!

Viewet sier fra hva den er interessert i å lytte på og får beskjed når
handlingen skjer.

Dette gir løsere koblinger mellom model og view  og skiller ansvaret ut der det hører hjemme.

    .javascript
    var user = new BEKK.User();

    user.on("test", function() { console.log("TESTING!"); });

    user.trigger("test");

Når et modell kaller `fetch` og kallet ender i suksess, trigges automatisk
eventen `fetch:finished`

---

# Oppgave

    .javascript
    it("should populate the view when data is fetched", function(){
        // Refaktorering av oppgaven over til å
        // benytte seg av events på ferdig henting av data
    });

Hint: Tredje parameter i `on` er kontekst (altså `this`)

---

# Gjennomgang av oppgave

Test:

    .javascript
    it("should show user info when rendered", function(){
        // sinon fakeserver

        var user = new BEKK.User({screen_name: "kimjoar"});
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        user.fetch();

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        expect(view.DOM(".followers")).toHaveText("200");
        expect(view.DOM(".following")).toHaveText("100");

        // bryt ned sinon fakeserver
    });

Kode:

    .javascript
    BEKK.UserView = BEKK.View.extend({
      initialize: function(options) {
        // ...
        this.user.on("fetch:finished", this.render, this);
      }
    });

---

# En testabstraksjon: fakeResponse

Det er grusomt kjedelig å skrive:

    .javascript
    this.server = sinon.fakeServer.create();
    this.server.respondWith([200, this.options, this.response]);
    // ...
    this.server.respond();
    this.server.restore();

Løsning: `fakeResponse` (se i `helper/fakeResponse.js`)

    .javascript
    fakeResponse(response, options, function() {
        // Alle AJAX-kall i denne callbacken vil få `response` som respons.
    });

---

# Oppgave

    .javascript
    it("should show user info when rendered", function(){
        // refaktorer oppgaven til å benytte seg av fakeResponse
    });

---

# Gjennomgang av oppgave

Test:

    .javascript
    it("should show user info when rendered", function(){
        var user = new BEKK.User({screen_name: "kimjoar"});
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        fakeResponse(this.response, this.options, function() {
          user.fetch();
        });

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        expect(view.DOM(".followers")).toHaveText("200");
        expect(view.DOM(".following")).toHaveText("100");
    });

---

# Lytte på DOM-eventer

I tillegg til å oppdatere DOM-en, er et view ansvarlig for å lytte på
DOM-eventer.

Alle DOM-eventene viewet lytter på, kan legges i `events`-property-en:

    .javascript
    var UserView = BEKK.View.extend({
        events: {
          "click h1": "editHeading"
          // "event selektor": "funksjon"
        },

        editHeading: function() {}
    });

---

# Globale events

Når flere komponenter kan være interessert i en handling som har skjedd.

Løsere kobling mellom komponenter.

    .javascript
    Simple.events.on("new-status", function(data) {
      console.log(data);
    });

    Simple.events.trigger("new-status", "The status");

---

# Teste eventer

Eventer er API-et til en komponent.

For å sjekke at en event fyrer korrekt, kan vi bruke en *spy*.

Eksempel med bruk av Sinon.js:

    .javascript
    var spy = sinon.spy();
    Simple.events.on("test", spy);

    // do something which should trigger "test"

    expect(spy).toHaveBeenCalledOnce();

Sjekk ut
[https://github.com/froots/jasmine-sinon](https://github.com/froots/jasmine-sinon)
for flere matchers.

---

# Oppgave

* `newStatusViewSpec.js`
* Få manglende tester i `monologSpec.js` til å kjøre.
* Siste spec i `userViewSpec.js`
* `statusesViewSpec.js`

Implementer `BEKK.start()` slik at app-en kjører.

---

# Sammensatte views

Et view kan bestå av flere views.

    .javascript
    BEKK.MasterView = BEKK.View.extend({
     initialize: function(options) {

      this.subView = new BEKK.SubView({ el: this.DOM("#sub") });
      this.otherView = new BEKK.OtherView({ el: this.DOM("#other")});
     },

     render: function() {
      this.subView.render();
      this.otherView.render();
     }
    });

    </textarea>
    <div id="slideshow" class="white"></div>
  </body>
</html>
